from helpers.formatter import Formatter
from slack_sdk.socket_mode import SocketModeClient
from slack_sdk.web import WebClient
from slack_sdk.socket_mode.response import SocketModeResponse
from slack_sdk.socket_mode.request import SocketModeRequest
from threading import Event, Thread
from integrations.slack.slack import SlackBot
from integrations.google.google import Google_handler
from integrations.google.templates.mail import customer_issue_template
from pprint import pprint
from integrations.jira.jira_handler import Jira_Handler
from app.models.JiraTicket import JiraTicket
from typing import List, Dict, Any
import traceback
from config import config
from logger import log

class Reporter:
    
    def __init__(self):
        self.gh = Google_handler()
        self.jh = Jira_Handler()
        self.formatter = Formatter()
        self.slackbot = SlackBot()

    def slackbot_listener(self, client: SocketModeClient, req: SocketModeRequest) -> None:
        """
        Handles incoming Slack events and determines if they should be queued for processing.
        Filters out events not sent by the designated monitoring bot.
        Args:
            client (SocketModeClient): Slack client instance.
            req (SocketModeRequest): Incoming Slack event payload.
        """

        # Responds to Slack
        response = SocketModeResponse(envelope_id=req.envelope_id)
        client.send_socket_mode_response(response)

        self.process_slack_event(req.payload) 

    def process_slack_event(self, slack_event) -> None:

        log.log("Slack event...")
        payload_event = slack_event['event']
        event_bot_id = payload_event.get('bot_id', '')
        if config.BOT_ID_DICT[event_bot_id] == "SERVE_AI_SUPPORT_BOT_ID": return # Skip processing for support bot events
        event_channel = config.CHANNEL_ID_DICT[payload_event.get('channel', '')]
        message_timestamp = payload_event['ts']
        if event_bot_id: print("EVENT BOT ID:", event_bot_id)
        if event_bot_id in config.BOT_ID_DICT.keys():
            log.log(f"Incoming event from {event_channel}. Processing...")
            log.log(f"EVENT PAYLOAD: {slack_event}")

            try:
                feedback_message_content = self.formatter.parse_slack_payload(event_channel, slack_event)
                feedback_ticket_type = feedback_message_content.get('ticket_type', None)
                log.log(f'FEEDBACK MESSAGE CONTENT: {feedback_message_content}')

            except Exception as e:
                log.log(f"UNHANDLED ERROR WHEN PARSING SLACK PAYLOAD: {traceback.format_exc()})")
                return
            
        else:
            log.log("Slack event not generated by monitoring bot. Not processing.")
            if event_channel == "bot-testing":
                log.log("Event from bot-testing channel")
            log.log(f"EVENT PAYLOAD: {slack_event}")
            return


        if feedback_ticket_type in ['Bug', 'Task']:

            if feedback_ticket_type == 'Bug':
                ticket_assignee = 'QA Team'
            elif feedback_ticket_type == 'Task':
                ticket_assignee = 'Project Manager'

            try:
                jira_issue_key = self.submit_jira_ticket(payload=feedback_message_content)
                log.log(f"Jira issue created with key: {jira_issue_key}")
                reply_content = "Jira Issue Key: " + jira_issue_key
            except Exception as e:
                reply_content = "There was an error submitting the Jira ticket."
                log.log(f"ERROR SUBMITTING JIRA TICKET: {traceback.format_exc()}")

            try:
                log.log(f"Assigning Jira issue {jira_issue_key} assigned to {ticket_assignee}")
                self.jh.assign_ticket(jira_issue_key, config.JIRA_ASSIGNEE_ID_DICT[ticket_assignee])
                reply_content += f"\nJira issue assigned to {ticket_assignee}."
            except Exception as e:
                reply_content += f"\nThere was an error assigning the Jira ticket to {ticket_assignee}."
                log.log(f"ERROR ASSIGNING JIRA TICKET: {traceback.format_exc()}")

        else:
            reply_content = "No Jira ticket created for this feedback message."
            log.log(reply_content)
        
        if not event_bot_id or config.BOT_ID_DICT[event_bot_id] != "SERVE_AI_SUPPORT_BOT_ID":
            self.slackbot.reply_to_alert(channel=event_channel,ts=message_timestamp, content=reply_content)  
                                
    def get_slackbot_client(self):
        return self.slackbot.client
        
    def begin_slackbot_listen(self, client):
        client.socket_mode_request_listeners.append(self.slackbot_listener)
        client.connect()

        log.log("BOT IS LISTENING!")

        Event().wait()
        
        
    def email_issue(self, recipient_name, recipient_email, body, subject="Issue received by Genetica", sender_alias="support@getgenetica.com"):
        service = self.gh.gmail_authenticate()
        message_text = customer_issue_template.format(recipient_name=recipient_name, body=body)
        sender_alias = 'support@getgenetica.com'  # must be an alias of authenticated account
        # recipient = 'client@example.com'
        # subject = 'Hello from Genetica'
        # body = 'This is a test email from our support alias.'
        # print(f"Recipient email before creating message: {recipient_email}")

        message = self.gh.create_gmail_message(sender_alias=sender_alias, to=recipient_email, subject=subject, message_text=message_text)
        self.gh.send_gmail(service, 'me', message)
        
    def add_to_google_sheets(self, name, email, organization, issue, status="New"):
        service = self.gh.google_sheets_authenticate()
        sheet = service.open("Tickets").sheet1
        sheet.append_row([organization, name, email, issue, status])
        
    def submit_jira_ticket(self, payload):
        ticket_payload, ticket_url = JiraTicket.format_ser_jira_ticket(**payload)
        # print("TICKET PAYLOAD")
        # pprint(ticket_payload)
        issue_key = self.jh.post_jira_ticket(ticket_payload, ticket_url)
        return issue_key
    
